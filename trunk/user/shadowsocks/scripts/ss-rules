#!/bin/sh
#
# Copyright (C) 2021 GH-X

private_addr="0.0.0.0/8          10.0.0.0/8         100.64.0.0/10      127.0.0.0/8
              169.254.0.0/16     172.16.0.0/12      192.0.0.0/24       192.0.2.0/24
              192.31.196.0/24    192.52.193.0/24    192.88.99.0/24     192.168.0.0/16
              192.175.48.0/24    198.18.0.0/15      198.51.100.0/24    203.0.113.0/24
              224.0.0.0/4        240.0.0.0/4        255.255.255.255/32"

iptn="iptables -t nat"
iptm="iptables -t mangle"
iptf="iptables -t filter"
amtf="/tmp/SSP_AUTOM"

flush_rules()
{
echo -1000 > /proc/$$/oom_score_adj
nochain=0
if [ "$1" = "0" ] || [ "$1" = "1" ]; then
  iptables-save -c | grep -v -E "SSP_|TPROXY" | iptables-restore -c
else
  iptables-save -c | grep -v -E "SSP_OUTPUT|SSP_PREROUTING|SSP_RULES|SSP_INPUT|TPROXY" | iptables-restore -c
  $iptn -F SSP_AGENT || nochain=$(echo "$?")
  $iptm -F SSP_AGENT
  $iptm -X SSP_AGENT
fi
ipset destroy private
ipset destroy gfwlist
ipset destroy chnlist
ip route del local 0.0.0.0/0 dev lo table 100
ip rule del fwmark 0x64 lookup 100
ip route flush cache
rm -rf $amtf
return 0
}

gen_ipset()
{
ipset -! restore <<-EOF || return 1
  create private hash:net hashsize 64 maxelem 128
  create gfwlist hash:net hashsize 1024 maxelem 65536
  create chnlist hash:net hashsize 16384 maxelem 1000000
  $(for privateaddr in $private_addr; do echo "add private $privateaddr"; done)
  $(for blackip in $black_ip; do echo "add gfwlist $blackip"; done)
  $(for whiteip in $white_ip; do echo "add chnlist $whiteip"; done)
  $(cat ${gfw_list:=/dev/null} 2>/dev/null | grep -E "^([0-9]{1,3}\.){3}[0-9]{1,3}" | sed -e "s/^/add gfwlist /")
  $(cat ${chn_list:=/dev/null} 2>/dev/null | grep -E "^([0-9]{1,3}\.){3}[0-9]{1,3}" | sed -e "s/^/add chnlist /")
  $(cat ${chnexp_list:=/dev/null} 2>/dev/null | grep -E "^([0-9]{1,3}\.){3}[0-9]{1,3}" | sed -e "s/^/add chnlist /")
EOF
return 0
}

ipt_nat()
{
echo "*nat" > $amtf
if [ "$agent_mode" == "0" ] || [ "$agent_mode" == "1" ] || [ "$nochain" = "1" ]; then
  echo ":SSP_AGENT - [0:0]" >> $amtf
fi
[ "$nochain" = "1" ] && echo ":SSP_AUTOM - [0:0]" >> $amtf
echo ":SSP_OUTPUT - [0:0]" >> $amtf
echo ":SSP_PREROUTING - [0:0]" >> $amtf
echo ":SSP_RULES - [0:0]" >> $amtf
[ "$nochain" = "1" ] && for CIDR_08 in $(seq 1 223); do
  [ "$CIDR_08" = "10" ] || [ "$CIDR_08" = "127" ] || for CIDR_16 in $(seq 0 255); do
    echo "-A SSP_AUTOM -d $CIDR_08.$CIDR_16.0.0/16 -m limit --limit 3/sec --limit-burst 3 -j SSP_AGENT" >> $amtf
  done
done
echo "COMMIT" >> $amtf && iptables-restore --noflush < $amtf && rm -rf $amtf || return 1
$iptn -A SSP_PREROUTING -d $server_addr -j RETURN
$iptn -A SSP_PREROUTING -p tcp -j SSP_RULES
$iptn -A SSP_OUTPUT -d $server_addr -j RETURN
$iptn -A SSP_OUTPUT -p tcp -j SSP_RULES
$iptn -A SSP_RULES -m state --state RELATED,ESTABLISHED -j RETURN
$iptn -A SSP_RULES -m set --match-set private dst -j RETURN
[ "$agent_mode" == "0" ] && $iptn -A SSP_RULES -j SSP_AGENT
[ "$agent_mode" == "1" ] && $iptn -A SSP_RULES -m set --match-set chnlist dst -j RETURN
[ "$agent_mode" != "0" ] && $iptn -A SSP_RULES -m set --match-set gfwlist dst -j SSP_AGENT
[ "$agent_mode" == "2" ] && $iptn -A SSP_RULES -m set --match-set chnlist dst -j RETURN
[ "$agent_mode" == "2" ] && $iptn -A SSP_RULES -j LOG --log-prefix "ipnotset "
[ "$agent_mode" == "2" ] && $iptn -A SSP_RULES -j SSP_AUTOM
[ "$agent_mode" == "1" ] && $iptn -A SSP_RULES -j SSP_AGENT
[ "$agent_mode" == "2" ] && $iptn -A SSP_RULES -j RETURN
$iptn -A SSP_AGENT -p tcp -j REDIRECT --to-ports $local_port
$iptn -I OUTPUT 1 -j SSP_OUTPUT
$iptn -I PREROUTING 1 -j SSP_PREROUTING
return 0
}

ipt_filter()
{
$iptf -N SSP_INPUT
$iptf -A SSP_INPUT -m set --match-set private src -j RETURN
$iptf -A SSP_INPUT -s $server_addr -p tcp -m tcp --tcp-flags RST RST -m state --state RELATED,ESTABLISHED -m limit --limit 1/min --limit-burst 1 -j RETURN
$iptf -A SSP_INPUT -s $server_addr -p tcp -m tcp --tcp-flags RST RST -j DROP
$iptf -A SSP_INPUT -p tcp -m tcp --tcp-flags RST RST -m state --state INVALID,NEW -j DROP
$iptf -A SSP_INPUT -j RETURN
$iptf -I INPUT 1 -j SSP_INPUT
return 0
}

ipt_mangle()
{
if !(lsmod | grep -q xt_TPROXY ); then
  modprobe xt_TPROXY
fi
ip rule add fwmark 0x64 lookup 100
ip route add local 0.0.0.0/0 dev lo table 100
$iptm -N SSP_PREROUTING
$iptm -N SSP_OUTPUT
$iptm -N SSP_RULES
$iptm -N SSP_AGENT
$iptm -A SSP_PREROUTING -d $server_addr -j RETURN
$iptm -A SSP_PREROUTING -p udp -j SSP_RULES
$iptm -A SSP_OUTPUT -d $server_addr -j RETURN
$iptm -A SSP_OUTPUT -p udp -j SSP_RULES
$iptm -A SSP_RULES -m mark --mark 0x64/0x64 -j RETURN
$iptm -A SSP_RULES -m set --match-set private dst -j RETURN
[ "$agent_mode" == "0" ] && $iptm -A SSP_RULES -j SSP_AGENT
[ "$agent_mode" == "1" ] && $iptm -A SSP_RULES -m set --match-set chnlist dst -j RETURN
[ "$agent_mode" != "0" ] && $iptm -A SSP_RULES -m set --match-set gfwlist dst -j SSP_AGENT
[ "$agent_mode" == "2" ] && $iptm -A SSP_RULES -m set --match-set chnlist dst -j RETURN
[ "$agent_mode" == "2" ] && $iptm -A SSP_RULES -j LOG --log-prefix "ipnotset "
[ "$agent_mode" == "1" ] && $iptm -A SSP_RULES -j SSP_AGENT
[ "$agent_mode" == "2" ] && $iptm -A SSP_RULES -j RETURN
$iptm -A SSP_AGENT -p udp -m conntrack --ctstate NEW -j CONNMARK --set-mark 0x64/0x64
$iptm -A SSP_AGENT -p udp -m conntrack --ctstate NEW -j CONNMARK --restore-mark
$iptm -I OUTPUT 1 -j SSP_OUTPUT
$iptm -I PREROUTING 1 -j SSP_PREROUTING
$iptm -I PREROUTING 2 -p udp -m mark --mark 0x64/0x64 -j TPROXY --on-port $local_port
return 0
}

usage()
{
cat <<-EOF

  ss-rules [选项] [赋值]         [说明]
           -s     <server_addr>  服务器地址      支持域名
           -i     <local_port>   本地端口        
           -g     <gfw_list>     黑名单地址列表  IP/CIDR格式
           -c     <chn_list>     国内路由表      IP/CIDR格式
           -e     <chnexp_list>  白名单地址列表  IP/CIDR格式
           -b     <black_ip>     黑名单地址      多个IP/CIDR使用[,]隔开
           -w     <white_ip>     白名单地址      多个IP/CIDR使用[,]隔开
           -a     <agent_mode>   透明代理模式    全局代理[0] 国内路由表[1] 黑名单域名[2]
           -t                    透明代理协议    TCP[REDIRECT]
           -m                    透明代理协议    TCP[REDIRECT] UDP[TPROXY]
           -f                    清除规则        
           -h                    显示帮助        

EOF
exit $1
}

logger -st "SSP[$$]Rules" "任务开始" && \
while getopts ":s:i:g:c:e:b:w:a:tmfh" arg; do
  case "$arg" in
    s)
      [ -z "$OPTARG" ] && usage 2
      server_addr="$OPTARG"
      ;;
    i)
      [ -z "$OPTARG" ] && usage 2
      local_port="$OPTARG"
      ;;
    g)
      [ -z "$OPTARG" ] && usage 2
      gfw_list="$OPTARG"
      ;;
    c)
      [ -z "$OPTARG" ] && usage 2
      chn_list="$OPTARG"
      ;;
    e)
      [ -z "$OPTARG" ] && usage 2
      chnexp_list="$OPTARG"
      ;;
    b)
      [ -z "$OPTARG" ] && usage 2
      black_ip=$(echo "$OPTARG" | sed 's/,/ /g')
      ;;
    w)
      [ -z "$OPTARG" ] && usage 2
      white_ip=$(echo "$OPTARG" | sed 's/,/ /g')
      ;;
    a)
      [ -z "$OPTARG" ] && usage 2
      agent_mode="$OPTARG"
      ;;
    t)
      flush_rules $agent_mode 2>/dev/null && gen_ipset && ipt_nat && ipt_filter
      ;;
    m)
      flush_rules $agent_mode 2>/dev/null && gen_ipset && ipt_nat && ipt_filter && ipt_mangle
      ;;
    f)
      flush_rules 0 2>/dev/null
      ;;
    h)
      usage 0
      ;;
  esac
done

EC=$?
[ $EC -eq 0 ] && logger -st "SSP[$$]Rules" "任务成功" || logger -st "SSP[$$]Rules" "任务失败"
exit $EC
